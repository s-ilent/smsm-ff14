// DoF background blur generation
// ---- Created with 3Dmigoto v1.2.31 on Sat Mar 12 03:57:59 2016
// Don't look! My code sucks! Please don't look! I'm so sorry!

SamplerState sInputS_s : register(s0);
Texture2D<float4> sInputT : register(t0);


// 3Dmigoto declarations
#define cmp -
//Texture1D<float4> IniParams : register(t120);
//Texture2D<float4> StereoParams : register(t125);
float2 stereoScreenRes;

static const float2 searchOffsets[8] = {
    float2( 1.0, 0.0),
    float2(-1.0, 0.0),
    float2( 0.0, 1.0),
    float2( 0.0,-1.0),
    
    float2( 1.0, 1.0),
    float2(-1.0,-1.0),
    float2( 1.0,-1.0),
    float2(-1.0, 1.0)
};

#include "Common.h"

void main( 
  float4 v0 : SV_POSITION0,
  float4 v1 : TEXCOORD0,
  float4 v2 : TEXCOORD1,
  out float4 o0 : SV_TARGET0)
{
  float4 r0,r1,r2,r3;

  // Adapted from original shader in Skylight ENB developed by Aiyen. 
  // Based on bokeh method from Martins Uptis ( http://devlog-martinsh.blogspot.dk/ )
  static const float2 screenSize = float2( 0.5625, 1.0); // 16:9 ratio
  //static float BlurSize = 0.016;
  //static float BlurSize = 0.030;
  static float BlurSize = 0.030;

  // Sample count. The high defaults are because it's calculated in a lower resolution.
  // Going higher also has little visual difference. 
  static int rings = 5;   // From 3 to 6 [5]
  static int samples = 5; // From 3 to 9 [7]
  static float BokehBias = 0.05;

  float w = screenSize.x;
  float h = screenSize.y;

  // Compensate for ring size boost.
  w /= rings;
  h /= rings;

  float2 v[4] = {
    v1.xy, // left down
    v1.zw, // right down
    v2.xy, // right up
    v2.zw, // left up
  };

  float2 vertA; // Cheap hack to get the centre position.
  vertA.x = v1.x + v1.z + v2.x + v2.z;
  vertA.y = v1.y + v1.w + v2.y + v2.w;
  vertA /= 4;

  //static float Blur = 2.0;
  // New! This solution was so obvious, I shoulda seen it.
  float Blur = sInputT.Sample(sInputS_s, vertA).w;

  if (true) { // Hacked together 
    Blur -= 0.5; // Focal point offset
    //Blur = Blur*Blur;
    //Blur = Blur*Blur;
    //Blur *= 2;
    //Blur = saturate(Blur);
    /*
    Blur = Blur * Blur;
    {
      float x = sign(Blur);
      Blur = max(abs(Blur), 0.15) * x;
    }
    */
  } 

  if (false) { // Skylight code... not correctly implemented.
    float Depth = Blur;
    float FDepth = 0.5;
    float FocalLength = 0.1;
    float CoC = 0.030;
    float a = (Depth * FocalLength)/(Depth - FocalLength); 
    float b = (FDepth * FocalLength)/(FDepth - FocalLength); 
    float c = (FDepth - FocalLength)/(FDepth * CoC); 
    Blur = abs(a-b)*c;
  }

  // DoF code

  float4 col = 0;
  uint j = 0;
  float s = 1.0; // Sample Counter 

    [unroll]
    for (int i = 1; i <= rings; i += 1)
    {
    int ringsamples = i*samples;
      [unroll]
      for (int j = 0 ; j < ringsamples ; j += 1) 
      {
        float Cpoint = 3.14159265 * 2.0 / float(ringsamples);
        float pw = (cos(float(j)*Cpoint) * float(i));
        float ph = (sin(float(j)*Cpoint) * float(i));

        float2 sampleLoc = vertA + float2(pw*w, ph*h) * Blur * BlurSize;

        //if (sign(Blur)) {
        {
          float sampleBlur = sInputT.Sample(sInputS_s, sampleLoc).w;
          //sampleLoc = lerp(vertA, sampleLoc, max(Blur,sampleBlur)); 
          sampleLoc = lerp(vertA, sampleLoc, sampleBlur-Blur); 
        }
  
        col += sInputT.Sample(sInputS_s, sampleLoc) * lerp(1.0, (float(i) / float(rings)) * 25.0, BokehBias);
        
        s += 1.0 * lerp(1.0, (float(i) / float(rings)) * 25.0, BokehBias) ;       
      }
    }
    col /= s; 

  //o0.xyzw = col.xxxw;
  //col.xyz = Blur;
  o0.xyzw = col;
  return;
}

void orig( 
  float4 v0 : SV_POSITION0,
  float4 v1 : TEXCOORD0,
  float4 v2 : TEXCOORD1,
  out float4 o0 : SV_TARGET0)
{
  float4 r0,r1,r2,r3;
  uint4 bitmask, uiDest;
  float4 fDest;

  float4 v[3] = { v0,v1,v2 };
  r0.xyzw = float4(0,0,0,0);
  r1.x = 0;
  while (true) {
    r1.y = cmp((int)r1.x >= 2);
    if (r1.y != 0) break;
    r2.xyzw = sInputT.Sample(sInputS_s, v[r1.x+1].xy).xyzw;
    r2.xyzw = r2.xyzw + r0.xyzw;
    r3.xyzw = sInputT.Sample(sInputS_s, v[r1.x+1].zw).xyzw;
    r0.xyzw = r3.xyzw + r2.xyzw;
    r1.x = (int)r1.x + 1;
  }
  o0.xyzw = float4(0.25,0.25,0.25,0.25) * r0.xyzw;
  return;
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//   using 3Dmigoto v1.2.31 on Sat Mar 12 03:57:59 2016
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// sInput.S                          sampler      NA          NA    0        1
// sInputT                          texture  float4          2d    0        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float       
// TEXCOORD                 0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 1   xyzw        2     NONE   float   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_TARGET                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_sampler s0, mode_default
dcl_resource_texture2d (float,float,float,float) t0
dcl_input_ps linear v1.xyzw
dcl_input_ps linear v2.xyzw
dcl_output o0.xyzw
dcl_temps 4
dcl_indexrange v1.xyzw 2
mov r0.xyzw, l(0,0,0,0)
mov r1.x, l(0)
loop 
  ige r1.y, r1.x, l(2)
  breakc_nz r1.y
  sample_indexable(texture2d)(float,float,float,float) r2.xyzw, v[r1.x + 1].xyxx, t0.xyzw, s0
  add r2.xyzw, r0.xyzw, r2.xyzw
  sample_indexable(texture2d)(float,float,float,float) r3.xyzw, v[r1.x + 1].zwzz, t0.xyzw, s0
  add r0.xyzw, r2.xyzw, r3.xyzw
  iadd r1.x, r1.x, l(1)
endloop 
mul o0.xyzw, r0.xyzw, l(0.250000, 0.250000, 0.250000, 0.250000)
ret 
// Approximately 13 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
