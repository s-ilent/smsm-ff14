#ifndef COMMON_INCLUDED
#define COMMON_INCLUDED
// This is the file with some common, shared functions.
// Don't edit if you don't know what you're doing.

// ----- Dithering assist code

float remap_tri( float v )
{
    // Convert uniform distribution into triangle-shaped distribution.
    float orig = v*2.0 - 1.0;
    v = orig / sqrt( abs(orig) );
    v = max(-1.0, v); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
    v = v - sign(orig) + 0.5;

    return v;
    // result is range [-0.5,1.5] which is useful for actual dithering.
    // convert to [0,1] for output
    //return (v + 0.5f) * 0.5f;
}

float3 remap_tri( float3 c )
{
    return float3( remap_tri(c.r), remap_tri(c.g), remap_tri(c.b) );
}

// "Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR"
float3 ScreenSpaceDither( float2 vScreenPos : SV_POSITION ) : SV_Target
{   static const float dither_bits = 255.0; 
    float3 vDither = dot( float2( 171.0, 231.0 ), vScreenPos.xy) ;  
    vDither.rgb = frac( vDither.rgb / float3(103.0,71.0,97.0) );
    return (vDither.rgb / dither_bits); 
}


float3 ScreenSpaceDitherTri( float2 vScreenPos : SV_POSITION ) : SV_Target
{   static const float dither_bits = 255.0; 
    // Source: https://www.shadertoy.com/view/Md3XRf
    float3 vDither = dot( float2( 131.0, 312.0 ), vScreenPos.xy);
    vDither.rgb = frac( vDither.rgb / float3( 103.0, 71.0, 97.0 ) );
    vDither == remap_tri( vDither.rgb );
    return (vDither.rgb / dither_bits); 
}

float3 SweetFXFastDither3( float2 vScreenPos : SV_POSITION ) : SV_Target
{   float dither_bit = 8.0; //Bit-depth of output. Normally 8 but some LCD monitors are 7 or even 6-bit. 
    //Calculate grid position
    float grid_position = frac( dot( vScreenPos.xy - float2(0.5,0.5) , float2(1.0/16.0,10.0/36.0) + 0.25 ) ); // v0
    //Calculate how big the shift should be
    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));
    //Shift the individual colors differently, thus making it even harder to see the dithering pattern
    float3 dither_shift_RGB = float3(dither_shift, -dither_shift, dither_shift); //subpixel dithering
    float dither_range = 3.0; // original: 2.0
    //modify shift acording to grid position.
    dither_shift_RGB = lerp(dither_range * dither_shift_RGB, -dither_range * dither_shift_RGB, grid_position); //shift acording to grid position.  return 
    //shift the color by dither_shift
    return 0.5/255.0 + dither_shift_RGB; 
}

float SweetFXFastDither( float2 vScreenPos : SV_POSITION ) : SV_Target
{   float dither_bit = 8.0; //Bit-depth of output. Normally 8 but some LCD monitors are 7 or even 6-bit. 
    //Calculate grid position
    float grid_position = frac( dot( vScreenPos.xy - float2(0.5,0.5) , float2(1.0/16.0,10.0/36.0) + 0.25 ) ); // v0
    //Calculate how big the shift should be
    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));
    //Shift the individual colors differently, thus making it even harder to see the dithering pattern
    //float3 dither_shift_RGB = float3(dither_shift, -dither_shift, dither_shift); //subpixel dithering
    //modify shift acording to grid position.
    //dither_shift_RGB = lerp(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); //shift acording to grid position.
    dither_shift = lerp(2.0 * dither_shift, -2.0 * dither_shift, grid_position); //shift acording to grid position.
    //shift the color by dither_shift
    //return 0.5/255.0 + dither_shift_RGB; 
    return 0.5/255.0 + dither_shift; 
}

// Interleaved Gradient Noise
float interleaved_gradient(float2 uv : SV_POSITION) : SV_Target
{
    float3 magic = float3(0.06711056, 0.00583715, 52.9829189);
    return frac(magic.z * frac(dot(uv, magic.xy)));
}

#define MAX_LEVEL 4.
float GetBayerFromCoordLevel(float2 pixelpos) // Src: https://www.shadertoy.com/view/XtV3RG
{
  float finalBayer   = 0.,
        finalDivisor = 0.,
          mult         = 1.;
    
    for(float bayerLevel = MAX_LEVEL; bayerLevel >= 1.; bayerLevel--)
  {
    float2 bayercoord = fmod(floor(2.*pixelpos/exp2(bayerLevel)), 2.);
        mult *= 4.;
    
    float line0202 = bayercoord.x*2.;

    finalBayer += lerp(line0202,3.-line0202,bayercoord.y) / 3. * mult;
    finalDivisor += mult;
  }

  return finalBayer / finalDivisor;
}

float3 ign3(float2 uv : SV_POSITION) : SV_Target
{
  float output = interleaved_gradient(uv);
  float dither_bit = 8.0; //Bit-depth of output. Normally 8 but some LCD monitors are 7 or even 6-bit. 
  float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));
  float3 dither_shift_RGB = float3(dither_shift, -dither_shift, dither_shift); //subpixel dithering
  float dither_range = 3.0; // original: 2.0
  //modify shift acording to grid position.
  dither_shift_RGB = lerp(dither_range * dither_shift_RGB, -dither_range * dither_shift_RGB, output); //shift acording to grid position.  return 
  return 0.5/255.0 + dither_shift_RGB; 
}

float nrand(float2 n) { // Src: https://www.shadertoy.com/view/4df3RH
  
  return frac(sin(dot(n.xy, float2(12.9898, 78.233)))* 43758.5453);
}

// R dither mask
float r2_intensity(float2 pixel) {
    const float a1 = 0.75487766624669276;
    const float a2 = 0.569840290998;
    return frac(a1 * float(pixel.x) + a2 * float(pixel.y));
}

float3 r2_intensity3(float2 uv : SV_POSITION) : SV_Target
{
  float output = r2_intensity(uv);
  float dither_bit = 8.0; //Bit-depth of output. Normally 8 but some LCD monitors are 7 or even 6-bit. 
  float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));
  float3 dither_shift_RGB = float3(dither_shift, -dither_shift, dither_shift); //subpixel dithering
  float dither_range = 3.0; // original: 2.0
  //modify shift acording to grid position.
  dither_shift_RGB = lerp(dither_range * dither_shift_RGB, -dither_range * dither_shift_RGB, output); //shift acording to grid position.  return 
  return 0.5/255.0 + dither_shift_RGB; 
}

// ALU 2x2 dither
float ALUdither (float2 fragCoord : SV_POSITION) : SV_Target
{
    //note: 2x2 ordered dithering, ALU-based (omgthehorror)
    //float2 ij = floor(mod( fragCoord.xy, float2(2.0) ));
    float2 ij = fmod( fragCoord.xy, 2.0 );
    ij = floor(ij);
    float idx = ij.x + 2.0*ij.y;
    float4 m = idx-float4(0,1,2,3);
    m = abs(m);
    m = step( m, 0.5 );
    m = m * float4(0.75,0.25,0.00,0.50);
    float d = m.x+m.y+m.z+m.w;
    return 0.5/255.0 + d; 
}

#define g(a) (4-(a).x-((a).y<<1))%4

float bayer8x8(float2 p){
    int2 ip = int2(p);
    return float(
         g(ip>>2&1)    +
        (g(ip>>1&1)<<2)+
        (g(ip   &1)<<4)
    )/63.;
}
#undef g

// ----- Color processing assist code

// CeeJay.dk's cubic contrast 
float Cubic (float x) {    
        x = x * 2.0 - 1.0;
        return -x * abs(x) * 0.5 + x + 0.5;
}

static const float3 lumaCoef = float3(0.298909992f,0.586610019f,0.114480004f);
// Source: https://www.shadertoy.com/view/Md2XWw and https://www.shadertoy.com/view/4sBSDW
float Linear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}
float3 Linear3(float3 c){return float3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}
float Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}
float3 Srgb3(float3 c){return float3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}
float PhotoLuma(float3 c){return dot(c,lumaCoef);}
float max3(float x, float y, float z) { return max(x, max(y, z)); }
float max3(float3 xyz) { return max(xyz.x, max(xyz.y, xyz.z)); }

// ----- Material shader processing assist code

float perceptualRoughnessToRoughness(float perceptualRoughness)
{
    return perceptualRoughness * perceptualRoughness;
}

half roughnessToPerceptualRoughness(half roughness)
{
    return sqrt(roughness);
}

half smoothnessToRoughness(half smoothness)
{
    return (1 - smoothness) * (1 - smoothness);
}

float smoothnessToPerceptualRoughness(float smoothness)
{
    return (1 - smoothness);
}

float normalFiltering(float perceptualRoughness, const float3 worldNormal) {
    // Kaplanyan 2016, "Stable specular highlights"
    // Tokuyoshi 2017, "Error Reduction and Simplification for Shading Anti-Aliasing"
    // Tokuyoshi and Kaplanyan 2019, "Improved Geometric Specular Antialiasing"

    // This implementation is meant for deferred rendering in the original paper but
    // we use it in forward rendering as well (as discussed in Tokuyoshi and Kaplanyan
    // 2019). The main reason is that the forward version requires an expensive transform
    // of the half vector by the tangent frame for every light. This is therefore an
    // approximation but it works well enough for our needs and provides an improvement
    // over our original implementation based on Vlachos 2015, "Advanced VR Rendering".
    float _specularAntiAliasingVariance = 0.25;
    float _specularAntiAliasingThreshold = 0.25;

    float3 du = ddx(worldNormal);
    float3 dv = ddy(worldNormal);

    float variance = _specularAntiAliasingVariance * (dot(du, du) + dot(dv, dv));

    //float roughness = perceptualRoughnessToRoughness(perceptualRoughness);
    float roughness = smoothnessToRoughness(perceptualRoughness);
    float kernelRoughness = min(2.0 * variance, _specularAntiAliasingThreshold);
    float squareRoughness = saturate(roughness * roughness + kernelRoughness);

    return 1-roughnessToPerceptualRoughness(sqrt(squareRoughness));
}

#endif // COMMON_INCLUDED