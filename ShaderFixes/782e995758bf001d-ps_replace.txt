// Identified as vignette shader. 
// ---- Created with 3Dmigoto v1.2.31 on Sat Feb 27 19:16:17 2016
// Original shader code is the property of Square Enix. 

cbuffer cVignettingParam : register(b0)
{
  float4 cVignettingParam[2] : packoffset(c0);
}

// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);

// Helpers
#include "Common.h"

// Main

void main( 
  float4 v0 : SV_POSITION0,
  float2 v1 : TEXCOORD0,
  out float4 o0 : SV_TARGET0)
{
  float4 r0;
  uint4 bitmask, uiDest;
  float4 fDest;

  // Maybe modify dither amount by intensity? Current solution is enough
  //static float dStep = 0.0075; 

  r0.xy = cVignettingParam[0].xy * v1.xy; // Shape aspect
  r0.x = dot(r0.xy, r0.xy); // Create vignette
  r0.x = -cVignettingParam[0].z + r0.x; // Strength modifier

  o0.w = cVignettingParam[0].w * r0.x; // Overall intensity

  // Bayer matrix is slower than gradient noise, especially on older GPUs (?)
  // but it looks way better for vignette, which is computed at half resolution.
  float dither = bayer8x8(v0.xy);
  dither=mad(dither,2.0f,-1.0f);
  //dither=sign(dither)*(1.0f-sqrt(1.0f-abs(dither)));

  const float quantizationSteps = 128;
  dither *= 1.0/quantizationSteps;
  
  //const float grainBlackLimit = 0.5 * Linear1(1.0 / (quantizationSteps - 1.0));
  //const float grainAmount = 0.75 * (Linear1(1.0 / (quantizationSteps - 1.0)) - 1.0);

  //o0.w = dither * min(o0.w + grainBlackLimit, grainAmount) + o0.w;
  o0.w += dither;
  //o0.w = lerp(o0.w, o0.w+interleaved_gradient(v0.xy), dStep);

  o0.w = saturate(o0.w);
  
  o0.xyz = cVignettingParam[1].xyz; // Vignette colour
  return;
}

void orig( 
  float4 v0 : SV_POSITION0,
  float2 v1 : TEXCOORD0,
  out float4 o0 : SV_TARGET0)
{
  float4 r0;
  uint4 bitmask, uiDest;
  float4 fDest;

  r0.xy = cVignettingParam[0].xy * v1.xy;
  r0.x = dot(r0.xy, r0.xy);
  r0.x = -cVignettingParam[0].z + r0.x;
    o0.w = saturate(cVignettingParam[0].w * r0.x);
    o0.xyz = cVignettingParam[1].xyz;

  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//   using 3Dmigoto v1.2.31 on Sat Feb 27 19:16:17 2016
//
//
// Buffer Definitions: 
//
// cbuffer cVignettingParam
// {
//
//   float4 cVignettingParam[2];        // Offset:    0 Size:    32
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// cVignettingParam                  cbuffer      NA          NA    0        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float       
// TEXCOORD                 0   xy          1     NONE   float   xy  
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_TARGET                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb0[2], immediateIndexed
dcl_input_ps linear v1.xy
dcl_output o0.xyzw
dcl_temps 1
mul r0.xy, v1.xyxx, cb0[0].xyxx
dp2 r0.x, r0.xyxx, r0.xyxx
add r0.x, r0.x, -cb0[0].z
mul_sat o0.w, r0.x, cb0[0].w
mov o0.xyz, cb0[1].xyzx
ret 
// Approximately 6 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
 