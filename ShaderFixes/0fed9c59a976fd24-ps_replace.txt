// Radial blur and light rays
// ---- Created with 3Dmigoto v1.2.40 on Fri Sep 30 20:13:02 2016

// Modified to use dithered sampling to make it smoother
// Idea stolen from https://www.shadertoy.com/view/4dyXWy
// Caveats:
// The values were chosen for looks. 
// Radial blur will have a dithered appearance!
// This is hardly noticeable, but may be disliked. 

cbuffer cRadialBlurParam : register(b0)
{
	float4 cRadialBlurParam : packoffset(c0);
}

SamplerState sInputSampler : register(s0);
Texture2D<float4> sInputTex : register(t0);


// 3Dmigoto declarations
#define cmp -

//#include "Configuration.h"

#include "Common.h"

void main(
	float4 v0 : SV_POSITION0,
	float2 v1 : TEXCOORD0,
	out float4 o0 : SV_TARGET0)
{
	float4 color;
	float4 sample;

	// Calculate vector from pixel to light source in screen space.  
	float2 dtc = cRadialBlurParam.xy - v1.xy; 

	float decay = 0;
	static const float blurSamples = 8; // Default 4. 

		// Generate dithering
		float dither = interleaved_gradient( v0.yx );

		// Increase the intensity of dithering the further from the source we are.
		dither = dither * dtc;

		// Avoids a crazy bug where the game will massively slow down at oblique angles
		// because the dithering is too strong. 
		dither = clamp(dither, -1, 1);

		for (float i=0; i<blurSamples; i++) {
			//float iDither = i+(dither-0.5); // Change dither spread to -0.5 ... 0.5
			float iDither = i+(dither); // "GPUs round internally"
			float sampleSpread = cRadialBlurParam.w * iDither; 
			float sampleDecay  =  cRadialBlurParam.z * i; 

			sampleSpread /= blurSamples-1;
			sampleDecay = 1 - (sampleDecay * 1/blurSamples);

			float2 offset = dtc * sampleSpread;

			offset += v1.xy;
			sample = sInputTex.Sample(sInputSampler, offset).xyzw;
			color += sample * sampleDecay;
			decay += sampleDecay;
		}

		o0.xyzw = color / decay;
		return;
	}

	void main_dec2(
		float4 v0 : SV_POSITION0,
		float2 v1 : TEXCOORD0,
		out float4 o0 : SV_TARGET0)
	{
		float4 color;
		float4 sample;

	// Calculate vector from pixel to light source in screen space.  
	float2 dtc = cRadialBlurParam.xy - v1.xy; 

	float decay = 0;
	static const float blurSamples = 4; // Default 4. 

	for (float i=0; i<blurSamples; i++) {

		// Multiply by current sample
		float sampleSpread = cRadialBlurParam.w * i; 
		float sampleDecay  =  cRadialBlurParam.z * i;

		// Divide by number of samples
		sampleSpread /= blurSamples-1;
		// Decrease by samples?
		sampleDecay = 1 - (sampleDecay * 1/blurSamples);

		// Adjust the shift according to the sample
		float2 offset = dtc * sampleSpread;

		// Apply offset to the sample point
		offset += v1.xy;

		sample = sInputTex.Sample(sInputSampler, offset).xyzw;

		// 
		color += sample * sampleDecay;
		// 
		decay += sampleDecay;
	}
	o0.xyzw = color / decay;
	return;
}

void main_dec1(
	float4 v0 : SV_POSITION0,
	float2 v1 : TEXCOORD0,
	out float4 o0 : SV_TARGET0)
{
	float4 color;
	float4 sample;
	float2 dtc = cRadialBlurParam.xy + -v1.xy; // delta tex coord
	float decay = 0;
	const float blurSamples = 4;
	for (float i=0; i<blurSamples; i+=1) {
		float2 blurParam1 = cRadialBlurParam.wz * i;
		blurParam1.x /= blurSamples-1;
		blurParam1.y = -blurParam1.y * 1/blurSamples + 1;
		float2 offset = dtc * blurParam1.x + v1.xy;
		sample = sInputTex.Sample(sInputSampler, offset).xyzw;
		color += sample * blurParam1.y;
		decay += blurParam1.y;
	}
	o0.xyzw = color / decay;
	return;
}

void orig( 
	float4 v0 : SV_POSITION0,
	float2 v1 : TEXCOORD0,
	out float4 o0 : SV_TARGET0)
{
	float4 r0,r1,r2,r3;
	uint4 bitmask, uiDest;
	float4 fDest;

	r0.xy = cRadialBlurParam.xy + -v1.xy;
	r1.xyzw = float4(0,0,0,0);
	r0.zw = float2(0,0);
	while (true) {
		r2.x = cmp((int)r0.w >= 4);
		if (r2.x != 0) break;
		r2.x = (int)r0.w;
		r2.xy = cRadialBlurParam.wz * r2.xx;
		r2.x = 0.333333343 * r2.x;
		r2.y = -r2.y * 0.25 + 1;
		r2.xz = r0.xy * r2.xx + v1.xy;
		r3.xyzw = sInputTex.Sample(sInputSampler, r2.xz).xyzw;
		r1.xyzw = r3.xyzw * r2.yyyy + r1.xyzw;
		r0.z = r2.y + r0.z;
		r0.w = (int)r0.w + 1;
	}
	o0.xyzw = r1.xyzw / r0.zzzz;
	return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//   using 3Dmigoto v1.2.40 on Fri Sep 30 20:13:02 2016
//
//
// Buffer Definitions: 
//
// cbuffer cRadialBlurParam
// {
//
//   float4 cRadialBlurParam;           // Offset:    0 Size:    16
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// sInput.S                          sampler      NA          NA    0        1
// sInput.T                          texture  float4          2d    0        1
// cRadialBlurParam                  cbuffer      NA          NA    0        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float       
// TEXCOORD                 0   xy          1     NONE   float   xy  
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_TARGET                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb0[1], immediateIndexed
dcl_sampler s0, mode_default
dcl_resource_texture2d (float,float,float,float) t0
dcl_input_ps linear v1.xy
dcl_output o0.xyzw
dcl_temps 4
add r0.xy, -v1.xyxx, cb0[0].xyxx
mov r1.xyzw, l(0,0,0,0)
mov r0.zw, l(0,0,0,0)
loop 
	ige r2.x, r0.w, l(4)
	breakc_nz r2.x
	itof r2.x, r0.w
	mul r2.xy, r2.xxxx, cb0[0].wzww
	mul r2.x, r2.x, l(0.333333343)
	mad r2.y, -r2.y, l(0.250000), l(1.000000)
	mad r2.xz, r0.xxyx, r2.xxxx, v1.xxyx
	sample_indexable(texture2d)(float,float,float,float) r3.xyzw, r2.xzxx, t0.xyzw, s0
	mad r1.xyzw, r3.xyzw, r2.yyyy, r1.xyzw
	add r0.z, r0.z, r2.y
	iadd r0.w, r0.w, l(1)
endloop 
div o0.xyzw, r1.xyzw, r0.zzzz
ret 
// Approximately 18 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
